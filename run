#!/usr/bin/env bash

# ═══════════════════════════════════════════════════════════════════════════════
# Shell Configuration Script - Fixed Version
# Customize .zshrc and .bashrc files across Linux distributions
# ═══════════════════════════════════════════════════════════════════════════════

# Configuration constants
readonly SCRIPT_VERSION="0.0.4"
readonly SCRIPT_NAME="Shell Configuration Tool"
readonly TEMPLATES_DIR="templates"
readonly LOG_FILE="/tmp/shell_config_$(date +%Y%m%d_%H%M%S).log"

# System information
TERM_WIDTH=$(tput cols 2>/dev/null || echo 80)
TERM_HEIGHT=$(tput lines 2>/dev/null || echo 24)
CURRENT_USER="${SUDO_USER:-$USER}"
USER_HOME=$(eval echo "~$CURRENT_USER")

# Color codes - using simple variables instead of associative arrays for better compatibility
readonly COLOR_RESET='\033[0m'
readonly COLOR_BOLD='\033[1m'
readonly COLOR_DIM='\033[2m'
readonly COLOR_ITALIC='\033[3m'
readonly COLOR_UNDERLINE='\033[4m'

# Standard colors
readonly COLOR_BLACK='\033[30m'
readonly COLOR_RED='\033[31m'
readonly COLOR_GREEN='\033[32m'
readonly COLOR_YELLOW='\033[33m'
readonly COLOR_BLUE='\033[34m'
readonly COLOR_MAGENTA='\033[35m'
readonly COLOR_CYAN='\033[36m'
readonly COLOR_WHITE='\033[37m'

# Bright colors
readonly COLOR_BRIGHT_BLACK='\033[90m'
readonly COLOR_BRIGHT_RED='\033[91m'
readonly COLOR_BRIGHT_GREEN='\033[92m'
readonly COLOR_BRIGHT_YELLOW='\033[93m'
readonly COLOR_BRIGHT_BLUE='\033[94m'
readonly COLOR_BRIGHT_MAGENTA='\033[95m'
readonly COLOR_BRIGHT_CYAN='\033[96m'
readonly COLOR_BRIGHT_WHITE='\033[97m'

# Unicode symbols for better visual appeal
readonly SYMBOL_CHECK="✓"
readonly SYMBOL_CROSS="✗"
readonly SYMBOL_WARNING="⚠"
readonly SYMBOL_INFO="ℹ"
readonly SYMBOL_ARROW="→"
readonly SYMBOL_BULLET="●"
readonly SYMBOL_DIAMOND="♦"
readonly SYMBOL_ROCKET="🚀"
readonly SYMBOL_SPARKLES="✨"

# ═══════════════════════════════════════════════════════════════════════════════
# UTILITY FUNCTIONS - Enhanced and more compatible versions
# ═══════════════════════════════════════════════════════════════════════════════

# Function to get color code by name - replaces associative array lookup
get_color_code() {
    local color_name="$1"
    case "$color_name" in
        "RESET") echo "$COLOR_RESET" ;;
        "BOLD") echo "$COLOR_BOLD" ;;
        "DIM") echo "$COLOR_DIM" ;;
        "ITALIC") echo "$COLOR_ITALIC" ;;
        "UNDERLINE") echo "$COLOR_UNDERLINE" ;;
        "BLACK") echo "$COLOR_BLACK" ;;
        "RED") echo "$COLOR_RED" ;;
        "GREEN") echo "$COLOR_GREEN" ;;
        "YELLOW") echo "$COLOR_YELLOW" ;;
        "BLUE") echo "$COLOR_BLUE" ;;
        "MAGENTA") echo "$COLOR_MAGENTA" ;;
        "CYAN") echo "$COLOR_CYAN" ;;
        "WHITE") echo "$COLOR_WHITE" ;;
        "BRIGHT_BLACK") echo "$COLOR_BRIGHT_BLACK" ;;
        "BRIGHT_RED") echo "$COLOR_BRIGHT_RED" ;;
        "BRIGHT_GREEN") echo "$COLOR_BRIGHT_GREEN" ;;
        "BRIGHT_YELLOW") echo "$COLOR_BRIGHT_YELLOW" ;;
        "BRIGHT_BLUE") echo "$COLOR_BRIGHT_BLUE" ;;
        "BRIGHT_MAGENTA") echo "$COLOR_BRIGHT_MAGENTA" ;;
        "BRIGHT_CYAN") echo "$COLOR_BRIGHT_CYAN" ;;
        "BRIGHT_WHITE") echo "$COLOR_BRIGHT_WHITE" ;;
        *) echo "$COLOR_WHITE" ;;  # Default fallback
    esac
}

# Function to get symbol by name - replaces associative array lookup
get_symbol() {
    local symbol_name="$1"
    case "$symbol_name" in
        "CHECK") echo "$SYMBOL_CHECK" ;;
        "CROSS") echo "$SYMBOL_CROSS" ;;
        "WARNING") echo "$SYMBOL_WARNING" ;;
        "INFO") echo "$SYMBOL_INFO" ;;
        "ARROW") echo "$SYMBOL_ARROW" ;;
        "BULLET") echo "$SYMBOL_BULLET" ;;
        "DIAMOND") echo "$SYMBOL_DIAMOND" ;;
        "ROCKET") echo "$SYMBOL_ROCKET" ;;
        "SPARKLES") echo "$SYMBOL_SPARKLES" ;;
        *) echo "●" ;;  # Default fallback
    esac
}

# Enhanced color printing function with better compatibility
print_colored() {
    local text="$1"
    local color_key="$2"
    local style_key="${3:-}"
    
    local color_code
    local style_code
    
    color_code=$(get_color_code "$color_key")
    if [[ -n "$style_key" ]]; then
        style_code=$(get_color_code "$style_key")
    else
        style_code=""
    fi
    
    echo -e "${style_code}${color_code}${text}${COLOR_RESET}"
}

# Enhanced banner with dynamic width adjustment
print_banner() {
    clear
    local banner_width=$((TERM_WIDTH > 80 ? 80 : TERM_WIDTH - 4))
    local padding=$(((banner_width - 30) / 2))
    
    echo
    print_colored "$(printf "%${banner_width}s" | tr ' ' '═')" "BRIGHT_CYAN" "BOLD"
    print_colored "$(printf "%${padding}s")$(get_symbol "ROCKET") $SCRIPT_NAME $(get_symbol "ROCKET")$(printf "%${padding}s")" "BRIGHT_WHITE" "BOLD"
    print_colored "$(printf "%${padding}s")Enhanced Shell Configuration$(printf "%${padding}s")" "BRIGHT_YELLOW"
    print_colored "$(printf "%${padding}s")Version $SCRIPT_VERSION$(printf "%${padding}s")" "BRIGHT_GREEN" "DIM"
    print_colored "$(printf "%${banner_width}s" | tr ' ' '═')" "BRIGHT_CYAN" "BOLD"
    echo
}

# Enhanced status display with icons and colors
print_status() {
    local message="$1"
    local status="$2"
    local detail="${3:-}"
    
    local icon color
    case "$status" in
        "SUCCESS"|"OK")
            icon=$(get_symbol "CHECK")
            color="BRIGHT_GREEN"
            ;;
        "ERROR"|"FAIL")
            icon=$(get_symbol "CROSS")
            color="BRIGHT_RED"
            ;;
        "WARNING"|"WARN")
            icon=$(get_symbol "WARNING")
            color="BRIGHT_YELLOW"
            ;;
        "INFO")
            icon=$(get_symbol "INFO")
            color="BRIGHT_BLUE"
            ;;
        "SKIP")
            icon=$(get_symbol "ARROW")
            color="BRIGHT_BLACK"
            ;;
        *)
            icon=$(get_symbol "BULLET")
            color="WHITE"
            ;;
    esac
    
    local color_code
    color_code=$(get_color_code "$color")
    
    printf "  ${color_code}%s${COLOR_RESET} %-40s" "$icon" "$message"
    
    if [[ -n "$detail" ]]; then
        print_colored "$detail" "DIM"
    else
        echo
    fi
}

# Enhanced section headers with decorative elements
print_section() {
    local title="$1"
    local width=$((TERM_WIDTH > 60 ? 60 : TERM_WIDTH - 4))
    local title_len=${#title}
    local padding=$(((width - title_len - 4) / 2))
    
    echo
    print_colored "$(printf "%${padding}s")$(get_symbol "DIAMOND") $title $(get_symbol "DIAMOND")$(printf "%${padding}s")" "BRIGHT_MAGENTA" "BOLD"
    print_colored "$(printf "%${width}s" | tr ' ' '─')" "MAGENTA"
}

# Interactive menu system with enhanced visuals
show_menu() {
    local title="$1"
    shift
    local options=("$@")
    
    print_section "$title"
    echo
    
    for i in "${!options[@]}"; do
        local option_num=$((i + 1))
        print_colored "  $option_num) ${options[i]}" "BRIGHT_WHITE"
    done
    echo
}

# Enhanced user input with validation
get_user_choice() {
    local prompt="$1"
    local max_choice="$2"
    local choice
    
    while true; do
        print_colored "$prompt" "BRIGHT_CYAN"
        read -r choice
        
        if [[ "$choice" =~ ^[1-9][0-9]*$ ]] && (( choice >= 1 && choice <= max_choice )); then
            echo "$choice"
            return 0
        else
            print_status "Invalid choice" "ERROR" "Please enter a number between 1 and $max_choice"
        fi
    done
}

# Confirmation dialog with enhanced styling
confirm_action() {
    local message="$1"
    local default="${2:-n}"
    local choice
    
    print_colored "$(get_symbol "WARNING") $message" "BRIGHT_YELLOW" "BOLD"
    
    if [[ "$default" == "y" ]]; then
        print_colored "Continue? (Y/n): " "BRIGHT_WHITE"
    else
        print_colored "Continue? (y/N): " "BRIGHT_WHITE"
    fi
    
    read -r choice
    choice="${choice:-$default}"
    
    [[ "$choice" =~ ^[Yy]$ ]]
}

# ═══════════════════════════════════════════════════════════════════════════════
# SYSTEM DETECTION AND VALIDATION
# ═══════════════════════════════════════════════════════════════════════════════

# Comprehensive system detection
detect_system() {
    print_section "System Detection"
    
    # Detect operating system
    if [[ -f "/etc/os-release" ]]; then
        source "/etc/os-release"
        DISTRO_NAME="$NAME"
        DISTRO_VERSION="$VERSION_ID"
        print_status "Distribution" "INFO" "$DISTRO_NAME $DISTRO_VERSION"
    else
        print_status "OS Detection" "WARNING" "Could not detect distribution"
        DISTRO_NAME="Unknown"
    fi
    
    # Detect current shell
    CURRENT_SHELL=$(basename "$SHELL")
    print_status "Current Shell" "INFO" "$CURRENT_SHELL"
    
    # Check available shells
    if command -v zsh >/dev/null 2>&1; then
        ZSH_AVAILABLE=true
        ZSH_VERSION=$(zsh --version | cut -d' ' -f2)
        print_status "Zsh Available" "SUCCESS" "Version $ZSH_VERSION"
    else
        ZSH_AVAILABLE=false
        print_status "Zsh Available" "WARNING" "Not installed"
    fi
    
    if command -v bash >/dev/null 2>&1; then
        BASH_AVAILABLE=true
        BASH_VERSION=$(bash --version | head -n1 | cut -d' ' -f4)
        print_status "Bash Available" "SUCCESS" "Version $BASH_VERSION"
    else
        BASH_AVAILABLE=false
        print_status "Bash Available" "ERROR" "Not found"
        exit 1
    fi
}

# Validate prerequisites
validate_prerequisites() {
    print_section "Prerequisites Check"
    
    # Check if running as root or with sudo
    if [[ $EUID -eq 0 ]] && [[ -z "$SUDO_USER" ]]; then
        print_status "User Check" "ERROR" "Please run with sudo, not as root"
        exit 1
    elif [[ $EUID -ne 0 ]] && [[ -z "$SUDO_USER" ]]; then
        print_status "User Check" "INFO" "Running as regular user"
    else
        print_status "User Check" "SUCCESS" "Running with appropriate privileges"
    fi
    
    # Check if templates directory exists
    if [[ -d "$TEMPLATES_DIR" ]]; then
        print_status "Templates Directory" "SUCCESS" "Found at $TEMPLATES_DIR"
    else
        print_status "Templates Directory" "ERROR" "Not found: $TEMPLATES_DIR"
        exit 1
    fi
    
    # Check for required template files
    local required_templates=("bashrc.template" "zshrc.template")
    for template in "${required_templates[@]}"; do
        if [[ -f "$TEMPLATES_DIR/$template" ]]; then
            print_status "$template" "SUCCESS" "Template found"
        else
            print_status "$template" "ERROR" "Template missing"
            exit 1
        fi
    done
    
    # Check user home directory
    if [[ -d "$USER_HOME" ]]; then
        print_status "User Home" "SUCCESS" "$USER_HOME"
    else
        print_status "User Home" "ERROR" "Cannot access $USER_HOME"
        exit 1
    fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# SHELL CONFIGURATION FUNCTIONS
# ═══════════════════════════════════════════════════════════════════════════════

# Configure Zsh with enhanced features
configure_zsh() {
    print_section "Configuring ZSH"
    
    local zshrc_file="$USER_HOME/.zshrc"
    local template_file="$TEMPLATES_DIR/zshrc.template"
    
    # Create backup if .zshrc exists
    if [[ -f "$zshrc_file" ]]; then
        local backup_file="${zshrc_file}.backup.$(date +%Y%m%d_%H%M%S)"
        cp "$zshrc_file" "$backup_file"
        print_status "Backup Created" "SUCCESS" "$backup_file"
    fi
    
    # Copy template to .zshrc
    if cp "$template_file" "$zshrc_file"; then
        print_status "Template Applied" "SUCCESS" "ZSH configuration updated"
    else
        print_status "Template Copy" "ERROR" "Failed to copy template"
        return 1
    fi
    
    # Set proper ownership and permissions
    if [[ -n "$SUDO_USER" ]]; then
        chown "$SUDO_USER:$SUDO_USER" "$zshrc_file"
    fi
    chmod 644 "$zshrc_file"
    print_status "Permissions Set" "SUCCESS" "644 permissions applied"
    
    # Check for Oh My Zsh installation
    if [[ -d "$USER_HOME/.oh-my-zsh" ]]; then
        print_status "Oh My Zsh" "SUCCESS" "Already installed"
    else
        print_status "Oh My Zsh" "WARNING" "Not found - may need manual installation"
    fi
    
    # Check for common Zsh plugins
    local plugin_dir="$USER_HOME/.oh-my-zsh/custom/plugins"
    local plugins=("zsh-syntax-highlighting" "zsh-autosuggestions")
    
    for plugin in "${plugins[@]}"; do
        if [[ -d "$plugin_dir/$plugin" ]]; then
            print_status "$plugin" "SUCCESS" "Plugin available"
        else
            print_status "$plugin" "WARNING" "Plugin not found"
        fi
    done
}

# Configure Bash with ble.sh support
configure_bash() {
    print_section "Configuring BASH"
    
    local bashrc_file="$USER_HOME/.bashrc"
    local template_file="$TEMPLATES_DIR/bashrc.template"
    
    # Create backup if .bashrc exists
    if [[ -f "$bashrc_file" ]]; then
        local backup_file="${bashrc_file}.backup.$(date +%Y%m%d_%H%M%S)"
        cp "$bashrc_file" "$backup_file"
        print_status "Backup Created" "SUCCESS" "$backup_file"
    fi
    
    # Copy template to .bashrc
    if cp "$template_file" "$bashrc_file"; then
        print_status "Template Applied" "SUCCESS" "BASH configuration updated"
    else
        print_status "Template Copy" "ERROR" "Failed to copy template"
        return 1
    fi
    
    # Set proper ownership and permissions
    if [[ -n "$SUDO_USER" ]]; then
        chown "$SUDO_USER:$SUDO_USER" "$bashrc_file"
    fi
    chmod 644 "$bashrc_file"
    print_status "Permissions Set" "SUCCESS" "644 permissions applied"
    
    # Check for ble.sh installation
    local blesh_locations=(
        "$USER_HOME/.local/share/blesh/ble.sh"
        "$USER_HOME/.local/lib/blesh/ble.sh"
        "/usr/local/share/blesh/ble.sh"
        "/usr/share/blesh/ble.sh"
    )
    
    local blesh_found=false
    for location in "${blesh_locations[@]}"; do
        if [[ -f "$location" ]]; then
            print_status "ble.sh Found" "SUCCESS" "$location"
            blesh_found=true
            break
        fi
    done
    
    if [[ "$blesh_found" == false ]]; then
        print_status "ble.sh" "WARNING" "Not found - enhanced features unavailable"
    fi
}

# Interactive shell selection
select_shell_configuration() {
    local options=()
    local shell_choices=()
    
    # Build available options based on system capabilities
    if [[ "$BASH_AVAILABLE" == true ]]; then
        options+=("Configure BASH with ble.sh integration")
        shell_choices+=("bash")
    fi
    
    if [[ "$ZSH_AVAILABLE" == true ]]; then
        options+=("Configure ZSH with Oh My Zsh integration")
        shell_choices+=("zsh")
    fi
    
    options+=("Configure BOTH shells")
    shell_choices+=("both")
    
    options+=("Exit without changes")
    shell_choices+=("exit")
    
    show_menu "Shell Configuration Options" "${options[@]}"
    
    local choice
    choice=$(get_user_choice "Select an option: " "${#options[@]}")
    
    local selected_option="${shell_choices[$((choice - 1))]}"
    
    case "$selected_option" in
        "bash")
            configure_bash
            ;;
        "zsh")
            configure_zsh
            ;;
        "both")
            configure_bash
            echo
            configure_zsh
            ;;
        "exit")
            print_status "Configuration" "INFO" "Exiting without changes"
            exit 0
            ;;
    esac
    
    return 0
}

# ═══════════════════════════════════════════════════════════════════════════════
# MAIN EXECUTION FLOW
# ═══════════════════════════════════════════════════════════════════════════════

# Display completion summary
show_completion_summary() {
    print_section "Configuration Complete"
    
    print_colored "$(get_symbol "SPARKLES") Successfully configured shell environment!" "BRIGHT_GREEN" "BOLD"
    echo
    
    print_status "Configuration Files" "INFO" "Updated in $USER_HOME"
    print_status "Backup Files" "INFO" "Created with timestamp"
    print_status "Log File" "INFO" "$LOG_FILE"
    
    echo
    print_colored "$(get_symbol "WARNING") Important: Please restart your terminal or run 'source ~/.bashrc' or 'source ~/.zshrc' to apply changes." "BRIGHT_YELLOW" "BOLD"
    echo
}

# Error handling and cleanup
cleanup_on_exit() {
    local exit_code=$?
    
    if [[ $exit_code -ne 0 ]]; then
        echo
        print_status "Script Execution" "ERROR" "Exited with code $exit_code"
        print_status "Log File" "INFO" "Check $LOG_FILE for details"
    fi
    
    # Restore terminal settings if needed
    tput cnorm 2>/dev/null || true
    
    exit $exit_code
}

# Main execution function
main() {
    # Set up error handling
    trap cleanup_on_exit EXIT
    
    # Hide cursor for cleaner output during execution
    tput civis 2>/dev/null || true
    
    # Display banner and system information
    print_banner
    
    # Perform system checks
    detect_system
    validate_prerequisites
    
    # Interactive configuration
    select_shell_configuration
    
    # Show completion summary
    show_completion_summary
    
    # Restore cursor
    tput cnorm 2>/dev/null || true
}

# Execute main function with comprehensive logging
{
    main "$@"
} 2>&1 | tee -a "$LOG_FILE"
